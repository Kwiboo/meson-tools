/*
 * Copyright (c) 2019 Andreas FÃ¤rber
 *
 * SPDX-License-Identifier: GPL-2.0-or-later WITH openvpn-openssl-exception
 */

#include <assert.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/sha.h>

#include "meson.h"

/*
 * COMPARE_MODE: Define this and change values below to match files
 * generated by aml_encrypt_gxl.
 */
#undef COMPARE_MODE

#ifndef COMPARE_MODE
/*
 * REPRODUCIBLE_OUTPUT: For the benefit of generating reproducible packages,
 * deviate from aml_encrypt_gxl in not using random / time-based values.
 */
#define REPRODUCIBLE_OUTPUT
#endif

static int append_file(const char *input, FILE *fout)
{
	FILE *fin;
	long len;
	uint8_t *buf;
	int ret = 0;

	fin = fopen(input, "rb");
	if (fin == NULL) {
		perror(input);
		return 1;
	}

	fseek(fin, 0, SEEK_END);
	len = ftell(fin);
	fseek(fin, 0, SEEK_SET);

	buf = malloc(len);
	if (buf == NULL) {
		ret = 1;
		goto err_malloc;
	}

	fread(buf, 1, len, fin);

	fwrite(buf, 1, len, fout);

	free(buf);
err_malloc:
	fclose(fin);
	return ret;
}

static int boot_img(const char *in_bl2, const char *in_fip,
	const char *in_bl30, const char *in_bl31, const char *in_bl33, const char *output)
{
	FILE *fin, *fout;
	uint8_t random[16];
	uint8_t *src_buf, *buf;
	struct AmlogicHeader hdr = {
		.sig = AMLOGIC_SIGNATURE,
		.size = 64,
		.header_size = 64,
		.header_version = 0x101,
		.encrypted = 0,
		.digest_offset = 64,
		.digest_size = 512,
	};
	SHA256_CTX sha256_ctx;
	uint8_t sha256_digest[SHA256_DIGEST_LENGTH];
	int ret;
#ifndef COMPARE_MODE
	int i;
#endif

	assert(sizeof(struct AmlogicHeader) == 64);

	src_buf = malloc(0xb000);
	if (src_buf == NULL)
		return 1;

	fout = fopen(output, "wb");
	if (fout == NULL) {
		perror(output);
		return 1;
	}

#ifdef COMPARE_MODE
	memcpy(random, (uint8_t[]){ 0x70, 0x8c, 0x67, 0x1e, 0x91, 0x7c, 0xdd, 0x79, 0x1e, 0xbf, 0xb2, 0xb8, 0xc7, 0xd8, 0x66, 0x55 }, 16);
#else
	for (i = 0; i < 16; i++)
#ifdef REPRODUCIBLE_OUTPUT
		random[i] = 0x42;
#else
		random[i] = rand();
#endif
#endif

	fwrite(random, 1, 16, fout);

	fin = fopen(in_bl2, "rb");
	if (fin == NULL) {
		perror(in_bl2);
		return 1;
	}

	fseek(fin, 0x1000, SEEK_SET);

	fread(src_buf, 1, 0xb000, fin);

	fclose(fin);

	hdr.size += hdr.digest_size;
	hdr.size += 0xdb0;
	hdr.size += 0xb000;
	hdr.digest_offset = hdr.header_size;
	hdr.data_offset = hdr.header_size + SHA256_DIGEST_LENGTH;
	hdr.padding_offset = hdr.digest_offset + 512;
	hdr.padding_size = 3504;
	hdr._offset2 = hdr.size - hdr.data_offset;
	hdr.payload_offset = hdr.padding_offset + hdr.padding_size;
	hdr.payload_size = 0xb000;

	buf = malloc(hdr.size);
	if (buf == NULL) {
		perror("malloc");
		return 1;
	}

	memset(buf, 0, hdr.size);
	memcpy(buf, &hdr, sizeof(struct AmlogicHeader));
	memcpy(buf + hdr.padding_offset + hdr.padding_size, src_buf, 0xb000);

#ifdef COMPARE_MODE
	memcpy(buf + 0x258, (uint8_t[]){ 0x98, 0x02 }, 2);
	memcpy(buf + 0x8ec, (uint8_t[]){ 0x40, 0x02 }, 2);
	memcpy(buf + 0xb20, (uint8_t[]){ 0x98, 0x02 }, 2);
#endif

	SHA256_Init(&sha256_ctx);
	SHA256_Update(&sha256_ctx, buf, hdr.header_size);
	SHA256_Update(&sha256_ctx, buf + hdr.data_offset, hdr._offset2);
	memset(sha256_digest, 0, sizeof(sha256_digest));
	SHA256_Final(sha256_digest, &sha256_ctx);
	memcpy(buf + hdr.digest_offset, sha256_digest, sizeof(sha256_digest));

	fwrite(buf, 1, hdr.size, fout);


	fseek(fout, 0xc000, SEEK_SET);

	ret = append_file(in_fip, fout);
	if (ret)
		return ret;


	fseek(fout, 0x10000, SEEK_SET);

	ret = append_file(in_bl30, fout);
	if (ret)
		return ret;

	fseek(fout, 0x20000, SEEK_SET);

	ret = append_file(in_bl31, fout);
	if (ret)
		return ret;

	fseek(fout, 0x3c000, SEEK_SET);

	ret = append_file(in_bl33, fout);
	if (ret)
		return ret;

	fclose(fout);

	free(src_buf);

	return 0;
}

int main(int argc, char **argv)
{
	if (argc < 7) {
		fprintf(stderr, "Usage: %s bl2 fip bl30 bl31 bl33 output\n", argv[0]);
		return 1;
	}

	return boot_img(argv[1], argv[2], argv[3], argv[4], argv[5], argv[6]);
}
