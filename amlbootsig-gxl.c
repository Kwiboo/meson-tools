/*
 * Copyright (c) 2017, 2019 Andreas FÃ¤rber
 *
 * SPDX-License-Identifier: GPL-2.0-or-later WITH openvpn-openssl-exception
 */

#include <assert.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/sha.h>

#include "meson.h"

/*
 * COMPARE_MODE: Define this and change values below to match files
 * generated by aml_encrypt_gxb.
 */
#undef COMPARE_MODE

#ifndef COMPARE_MODE
/*
 * REPRODUCIBLE_OUTPUT: For the benefit of generating reproducible packages,
 * deviate from aml_encrypt_gxl in not using random / time-based values.
 */
#define REPRODUCIBLE_OUTPUT
#endif

static int boot_sig(const char *input, const char *output)
{
	FILE *fin, *fout;
	uint8_t random[16];
	uint8_t *src_buf, *buf;
	struct AmlogicHeader hdr = {
		.sig = AMLOGIC_SIGNATURE,
		.size = 64,
		.header_size = 64,
		.header_version = 0x0101,
		.encrypted = 0,
		.digest_offset = 64,
		.digest_size = 512,
	};
	SHA256_CTX sha256_ctx;
	uint8_t sha256_digest[SHA256_DIGEST_LENGTH];
#ifndef COMPARE_MODE
	int i;
#endif

	assert(sizeof(struct AmlogicHeader) == 64);

	src_buf = malloc(0xc000);
	if (src_buf == NULL)
		return 1;

	fin = fopen(input, "rb");
	if (fin == NULL) {
		perror(input);
		return 1;
	}

	fout = fopen(output, "wb");
	if (fout == NULL) {
		perror(output);
		return 1;
	}

#ifdef COMPARE_MODE
	memcpy(random, (uint8_t[]){ 0x25, 0x66, 0x10, 0x39, 0x53, 0x45, 0x43, 0x2b, 0x10, 0xd7, 0x96, 0xe2, 0x68, 0xc2, 0x7a, 0x6a }, 16);
#else
	for (i = 0; i < 16; i++)
#ifdef REPRODUCIBLE_OUTPUT
		random[i] = 0x42;
#else
		random[i] = rand();
#endif
#endif

	fwrite(random, 1, 16, fout);

	fread(src_buf, 1, 0xc000, fin);

	if (strncmp(src_buf + 16, "@AML", 4) == 0) {
		fprintf(stderr, "@AML discovered in input!\n");
		return 1;
	}

	hdr.size += hdr.digest_size;
	hdr.size += 0xdb0;
	hdr.size += 0xb000;
	hdr.digest_offset = hdr.header_size;
	hdr.data_offset = hdr.header_size + SHA256_DIGEST_LENGTH;
	hdr.padding_offset = hdr.digest_offset + 512;
	hdr.padding_size = 3504;
	hdr._offset2 = hdr.size - hdr.data_offset;
	hdr.payload_offset = hdr.padding_offset + hdr.padding_size;
	hdr.payload_size = 0xb000;

	buf = malloc(hdr.size);
	if (buf == NULL) {
		perror("malloc");
		return 1;
	}

	memset(buf, 0, hdr.size);
	memcpy(buf, &hdr, sizeof(struct AmlogicHeader));
	memcpy(buf + hdr.padding_offset + hdr.padding_size, src_buf, 0xb000);

#ifdef COMPARE_MODE
	memcpy(buf + 0x258, (uint8_t[]){ 0x98, 0x02 }, 2);
	memcpy(buf + 0x8ec, (uint8_t[]){ 0x40, 0x02 }, 2);
	memcpy(buf + 0xb20, (uint8_t[]){ 0x98, 0x02 }, 2);
#endif

	SHA256_Init(&sha256_ctx);
	SHA256_Update(&sha256_ctx, buf, hdr.header_size);
	SHA256_Update(&sha256_ctx, buf + hdr.data_offset, hdr._offset2);
	memset(sha256_digest, 0, sizeof(sha256_digest));
	SHA256_Final(sha256_digest, &sha256_ctx);
	memcpy(buf + hdr.digest_offset, sha256_digest, sizeof(sha256_digest));

	fwrite(buf, 1, hdr.size, fout);

	fclose(fout);
	fclose(fin);

	free(src_buf);

	return 0;
}

int main(int argc, char **argv)
{
	if (argc < 3) {
		fprintf(stderr, "Usage: %s input output\n", argv[0]);
		return 1;
	}

	return boot_sig(argv[1], argv[2]);
}
